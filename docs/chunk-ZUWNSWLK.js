import{a as c}from"./chunk-U6LPWHCR.js";import{a as m}from"./chunk-J5WSNC3N.js";import"./chunk-T2TPJYPD.js";import"./chunk-GSP52HBJ.js";import{a as s}from"./chunk-D5VJN27U.js";import{X as w}from"./chunk-WOBS4B3T.js";import"./chunk-XH3XHKSK.js";import{Ba as i,Fa as d,Wa as l,sb as g}from"./chunk-AVEIMZJF.js";import{a as r,b as n,h as y}from"./chunk-TWZW5B45.js";var p=y(w());var D={title:"Introduction",mdFile:"./index.md",order:1,category:c},e=D;var h=[];var v={},u=v;var N=`<h1 id="introduction" href="signals-demo-walkthrough/introduction" headinglink="true" class="ngde">Introduction<ng-doc-heading-anchor class="ng-doc-anchor ngde" anchor="introduction"></ng-doc-heading-anchor></h1><p class="ngde">The demo application is meant to be a set of examples of how SmartNgRX works and what it can do. It demonstrates the following concepts:</p><ul class="ngde"><li class="ngde">Using the Angular Material Tree component and the CDK Virtual Scroll component, it demonstrates how to only load the data that is needed to display the part of the tree you can see.</li><li class="ngde">How to use the SmartNgRX library to manage the state of the application. (CRUD operations).</li><li class="ngde">How to implement web socket server to client communication.</li><li class="ngde">The various ways to handle refreshing and garbage collecting NgRX data (or not).</li></ul><p class="ngde">It was primarily built as a way to test the various features as they were built and we will add to it as more features are added or we find a need to demonstrate more features. One that quickly comes to mind is demonstrating the ability to have multiple parents of a row. This should work, but we've not yet tested it extensively.</p><h2 id="tabs" href="signals-demo-walkthrough/introduction" headinglink="true" class="ngde">Tabs<ng-doc-heading-anchor class="ng-doc-anchor ngde" anchor="tabs"></ng-doc-heading-anchor></h2><p class="ngde">Other than the main tab that describes each of the demo tabs, there are four tabs that each demonstrate a different way of managing state using SmartNgRX.</p><ul class="ngde"><li class="ngde"><strong class="ngde">Tree (Standard):</strong> This tab demonstrates the default Mark and Delete strategy that SmartNgRX uses.<ul class="ngde"><li class="ngde"><strong class="ngde">markDirtyTime:</strong> Marks a row as dirty every 15 minutes.</li><li class="ngde"><strong class="ngde">markDirtyFetchesNew:</strong> Uses the default of <code class="ngde">true</code> to fetch new data when a row is marked dirty.</li><li class="ngde"><strong class="ngde">removeTime:</strong> Removes a row from memory if it is still dirty 15 minutes after being marked dirty.</li><li class="ngde"><strong class="ngde">runInterval:</strong> Uses the default polling interval of 1 minute to mark rows dirty or remove them from memory.</li></ul></li><li class="ngde"><strong class="ngde">Tree (No Refresh):</strong> This tab demonstrates the No Refresh strategy that SmartNgRX can use. It also overrides the times to 2 minutes and 4 minutes. Instead of refreshing the data every 2 minutes, it does nothing. Later on, it removes the row if it hasn't been rendered 2 minutes after the last time it would have been marked dirty. While it doesn't refresh when it is marked dirty, it does act as though it did.<ul class="ngde"><li class="ngde"><strong class="ngde">markDirtyTime:</strong> Marks a row as dirty every 2 minutes.</li><li class="ngde"><strong class="ngde">markDirtyFetchesNew:</strong> Sets this value to <code class="ngde">false</code>. This is what causes the "No Refresh".</li><li class="ngde"><strong class="ngde">removeTime:</strong> Removes a row from memory if it is still dirty 2 minutes after being marked dirty.</li></ul></li><li class="ngde"><strong class="ngde">Tree (No Remove):</strong> This demo does not remove rows from memory once they've been loaded, but it does mark them dirty so they can be refreshed. You might use this feature if your application does not display a lot of data and can support the extra memory pressure. It can also make your application feel faster so you might strategically apply it to select entities in your application.<ul class="ngde"><li class="ngde"><strong class="ngde">markDirtyTime:</strong> Marks a row dirty every 2 minutes.</li><li class="ngde"><strong class="ngde">removeTime:</strong> This is set to <code class="ngde">0</code> so rows are never removed from memory.</li></ul></li><li class="ngde"><strong class="ngde">Tree (No Dirty):</strong> This demo sets the markDirtyTime to -1 so that nothing ever gets marked dirty. This means that data will never be refreshed and it will never be removed from memory. You would typically use this feature for lookup tables that don't change often so there is no reason to refresh them.<ul class="ngde"><li class="ngde"><strong class="ngde">markDirtyTime:</strong> This is set to -1 so that nothing ever gets marked dirty or gets removed from memory.</li></ul></li></ul>`,a=class t extends s{constructor(){super();this.pageType="guide";this.pageContent=N;this.editSourceFileUrl="https://github.com/DaveMBush/SmartNgRX/edit/main/apps/documentation/src/app/signals-demo-walkthrough/introduction/index.md?message=docs(): describe your changes here...";this.viewSourceFileUrl="https://github.com/DaveMBush/SmartNgRX/blob/release/apps/documentation/src/app/signals-demo-walkthrough/introduction/index.md";this.page=e;this.demoAssets=u}static{this.\u0275fac=function(o){return new(o||t)}}static{this.\u0275cmp=i({type:t,selectors:[["ng-doc-page-f62ypfzh"]],features:[g([{provide:s,useExisting:t},h,e.providers??[]]),d],decls:1,vars:0,template:function(o,T){o&1&&l(0,"ng-doc-page")},dependencies:[m],encapsulation:2,changeDetection:0})}},b=[n(r({},(0,p.isRoute)(e.route)?e.route:{}),{path:"",component:a,title:"Introduction"})],L=b;export{a as PageComponent,L as default};
